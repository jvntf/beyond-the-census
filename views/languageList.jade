// colors (mapzen?)
// dot density

extends layout

block content
    #map-container
      #map-panzoom
      #map-fixed
    
    #text-container
      #text-target

    
    script(type='text/javascript').
  
        /******************************** SETUP ********************************/
        
        // data containers (searchoptions is for fuzzy text search...)
        var input = {
            'filterstring': '',
            'filtertype': 'langname'
          }, searchOptions = {
              extract: function(el) { return el.language; }
          }, data = {
            languages: [],
            countries: [],
            neighborhoods: [],
            selected: {}
          }, map;
        
        //var map = new L.Map("map-panzoom", {center: [40.67, -73.78], zoom: 11.8});
        // todos
        // fix location sync between leaflet and d3 layers
        // add key to yaml: mapzen-3Sh1qQr
        // customize yaml  
                                     
        // setup basemap
        //mapboxgl.accessToken = 'pk.eyJ1IjoiY2Fyc3RvaWQiLCJhIjoiY2ozMzJ3aHVpMDA3YzJ3cTZ3ZTdlYzlvYyJ9.eNIdLcbC98a6fBMc8mJ1fQ'
        /*var map = new mapboxgl.Map({
            container: 'map-panzoom', // container id
            style: 'mapbox://styles/carstoid/cj4hk51ds272q2rqvzqw6brhw',
            center: [ -73.78, 40.67　],
            zoom: 10.7,
        });*/
        
        // fetch data and draw
        updateData( input.filtertype, input.filterstring, () => {
          updateList();
          draw();
        });
        
        /***************************** EVENT LISTENERS *************************/
        
        d3.select('#filtertext') 
            .on('input', function () {
              input.filterstring = d3.select(this).property('value');
              var q = d3.queue();
              //q.defer(delayedHello);
              q.defer( updateData, input.filtertype, input.filterstring );
              q.await(function(error) {
                if (error) throw error;
                draw();
                
              });              
            });
            
        /***************************** DRAW FUNCTIONS **************************/
                  
        function draw() { // calls group of draw functions, now just updateMap
          addLeafletMap();
          updateMap();
        }
        
        function updateList() { // show text details for highlighted language
          
          // setup
          var textTarget = d3.select('#text-target');
          var languageList = data.languages;
          
          var languageNest = d3.nest()
            .key(function(d) {return d.continents[0].properties.CONTINENT;})
            .sortKeys(d3.ascending)
            .key(function(d) {return d.endangermentNum;})
            .sortKeys(d3.ascending)
            .entries(data.languages);

          var uniqueContinents = d3.set(languageList, (item) => {
              return item.continents[0].properties.CONTINENT
            }).values();
                    
          // begin DOM manipulation   
          textTarget.selectAll('*').remove(); // clear container on refresh

          var continentItem = textTarget.selectAll('div')
              .data(languageNest)
            .enter().append('div')
              .attr('class', 'continent-item') // makes a list item for every group in the first level of the nest (continent)
              
          continentItem.datum( (d, i, n) => { // calculate color per continent and insert into child elements
            var dModified = d;
            var numContinents = n.length
            var hMap = d3.scaleLinear()
                .domain([0, numContinents])
                .range([0, 300]);
            dModified.color = d3.color( `hsl(${hMap(i)}, 80%, 50%)` );
            
            dModified.values.map( (item) => {
              var itemModified = item;
              itemModified.values.map( (subItem => {
                var subItemModified = subItem;
                subItemModified.continentColor = dModified.color;
                return subItemModified;
              }));
              return itemModified;
            })
            return dModified;
          })
                  
          continentItem.append("div") // label each continent item
              .attr('class', 'continent-item-label')
              .style('background', 'black')
              .style('color', 'white')                    
              .append('p')
              .text((d) => { return d.key });
              
          var languageList = continentItem.append("div") // make container for language list
              .attr('class', 'language-list')
              
          var endangermentItem = languageList.selectAll("div")
              .data( (d) => { return d.values} )
              .enter();
              
          var languageItem = endangermentItem.selectAll("span")
              .data( (d) => { return d.values } )
              .enter().append("span")
              .attr('class', 'language-item')
              .text((d) => {return d.language})
              .style('background', (d, i, n) => {
                var lMap = d3.scaleLinear()
                    .domain([0, 9])
                    .range([0.5, 1]);
                var colorAdjusted = d.continentColor
                colorAdjusted.l = lMap(d.endangermentNum)
                return colorAdjusted;
              })
              .style('color', (d, i, n) => {
                var lMap = d3.scaleLinear()
                    .domain([0, 9])
                    .range([0.5, 1]);
                var colorAdjusted = d.continentColor
                colorAdjusted.l = 0.2

                return colorAdjusted;
              })              
              .on('mouseover', (d, i, n) => {
                      updateGlobe(d);
                                        
                      d3.select('.neighborhood-centers').selectAll('g').selectAll('*').remove(); // clear all other line/label group contents

                      var listItemPoint = [],
                          mapPoint = [],
                          globePoint = [];

                      var listItemBounds = d3.select( n[i] )._groups[0][0].getBoundingClientRect();
                      //console.log(listItemBounds);
                      listItemPoint = [listItemBounds.left, listItemBounds.top + (listItemBounds.height/2) ];
                      
                      globePoint = parseTransform(d3.select('.globe-container').attr('transform')).translate;
                      
                      //console.log(n[i])
                                            
                      d.neighborhoods.forEach( (item, index) => {
                        let itemElement = d3.select(`#ID${item}`);
                        mapPoint[0] = parseTransform(itemElement.attr('transform')).translate[0];
                        mapPoint[1] = parseTransform(itemElement.attr('transform')).translate[1];
                        
                        var lMap = d3.scaleLinear()
                            .domain([0, 9])
                            .range([0.5, 1]);
                        var colorAdjusted = d.continentColor
                        colorAdjusted.l = lMap(d.endangermentNum)
                                                
                        connectTwoElements( item, listItemPoint , mapPoint, colorAdjusted.rgb() ) // draw line between two elements on mouseover
                        connectTwoElements( item, globePoint, mapPoint, colorAdjusted.rgb() ) // draw line between two elements on mouseover
                        
                      });
                    })

            
        /*  
        
            var ordinalConverter = d3.scaleOrdinal();
            ordinalConverter.domain(uniqueContinents);
            ordinalConverter.range([0, 60, 120, 180, 240 ]); // to hue range, could be 300 if this looks like 2 reds
            

                
            .on('mouseover', (d, i, n) => {
                updateGlobe(d);
                                  
                d3.select('.neighborhood-centers').selectAll('g').selectAll('*').remove(); // clear all other line/label group contents

                var listItemPoint = [],
                    mapPoint = [];

                var listItemBounds = d3.select( n[i] )._groups[0][0].getBoundingClientRect();
                console.log(listItemBounds);
                listItemPoint = [listItemBounds.left, listItemBounds.top + (listItemBounds.height/2) ];
            
                d.neighborhoods.forEach( (item, index) => {
                  let itemElement = d3.select(`#ID${item}`);
                  mapPoint[0] = parseTransform(itemElement.attr('transform')).translate[0];
                  mapPoint[1] = parseTransform(itemElement.attr('transform')).translate[1];
                  connectTwoElements( item, listItemPoint , mapPoint ) // draw line between two elements on mouseover
                });
                
                //d3.selectAll(n).attr("fill-opacity", 0.6); // reset opacity on all 
                //source.attr("fill-opacity", 1); // set opacity to full on selected 

                //d3.select('.neighborhood-centers').selectAll('g').selectAll('*').remove(); // clear all other line/label group contents
                
                //d3.selectAll(n).attr("fill-opacity", 0.6); // reset opacity on all 
                //source.attr("fill-opacity", 1); // set opacity to full on selected 
              }) */     
              
                     
            /*textTargetItem.append('span') 
              .attr('class', 'listitem-colorblock')
              .style('background', (d) => {
                let endangerment = d.endangermentNum;
                if ( isNaN(parseInt(endangerment)) ) {
                  //console.log('not a number: ' + endangerment )
                  endangerment = 9;
                } else {
                  //console.log(endangerment)
                }
                var remapperE = remapNumbers( 1, 9, 50, 100 ); // map list length to 360 degree range for color calculation
                
                let endangermentMap = remapperE(endangerment);
                let contMap = ordinalConverter(d.continents[0].properties.CONTINENT);
                return d3.color( `hsl(${contMap}, 80%, ${endangermentMap}%)` ).rgb();  
              })*/
              

              
            
        }
        
        function addLeafletMap() {
            map = new L.Map('map-panzoom', {zoomControl: false, attributionControl: false}).setView([40.67, -73.78], 11);
            
            /*L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
                attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
                maxZoom: 18,
                id: 'mapbox.streets',
                accessToken: 'pk.eyJ1IjoiY2Fyc3RvaWQiLCJhIjoiY2ozMzJ3aHVpMDA3YzJ3cTZ3ZTdlYzlvYyJ9.eNIdLcbC98a6fBMc8mJ1fQ'
            }).addTo(map);*/
            
            Tangram.leafletLayer({ scene: '../scene.yaml' }).addTo(map);
            
            L.svg().addTo(map);
        }
        
        function updateMap() {
          
            var neighborhoodsAll = {
                type: 'FeatureCollection',
                features: data.neighborhoods.filter( (neighborhood) => {
                  return neighborhood.properties.BoroCode == 4;
                })
            };
          
            var svg = d3.select('#map-panzoom').select('svg'); 
            
            svg.attr("width", window.innerWidth)
              .attr("height", window.innerHeight);
            //targetParent.selectAll("svg").remove();
            //var svg = targetParent.append("svg");
            
            var transform = d3.geoTransform({point: projectPoint});
          	var path = d3.geoPath().projection(transform);

            var width = window.innerWidth, 
                height = window.innerHeight;
                                                            
            var neighborhoodCenters = svg.append("g")
                .attr("class", "neighborhood-centers")
              .selectAll("g")
                .data(neighborhoodsAll.features)
              .enter().append("g")
                .attr("id", (d) => { return 'ID' + d._id } )
                .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; });
            
            var neighborhoodPolys = svg.append("g")
              .attr("class", "neighborhood-polys")
              .selectAll("path")
              .data(neighborhoodsAll.features)
              .enter().append("path")
              .attr("d", path)
              .style("stroke", "black")
              .style("stroke-opacity", "0.2")
              .style("fill", "black")
              .style("fill-opacity", (d) => {
                var nMap = d3.scaleLinear()
                    .domain([0, 15])
                    .range([0.2, 1.0]);
                if (d.properties.languages) {
                  //console.log(d.properties.languages)
                    return nMap(d.properties.languages.length)
                } else {
                  return 0.1;
                }
              });
            
            // update the path using the current transform
            function update() {
              neighborhoodCenters.attr("transform", function(d) {return "translate(" + path.centroid(d) + ")"; });
              neighborhoodPolys.attr("d", path);
              //console.log('update')
            }
            
            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
              
                //var point2 = map.project(new mapboxgl.LngLat(lon, lat));
                this.stream.point(point.x, point.y);
            }   
                        
            map.on("viewreset", update)
            map.on("movestart", function(){
            svg.classed("hidden", true);
            });	
            map.on("rotate", function(){
            svg.classed("hidden", true);
            });	
            map.on("moveend", function(){
            update()
            svg.classed("hidden", false);
            })
            update()                                    
        }// draws base map, colored bands, sets hover behavior, calls connectTwoElements
        
        function updateGlobe( item ) {
          //console.log(item);
          d3.selectAll('.globe-container').remove(); // clear globe
          var rotation = [ -item.longitude, -item.latitude ];
          var width = window.innerWidth,
              height = window.innerHeight;
              
          init();

          function init(){
              // set projection 
              var projection = d3.geoOrthographic()
                  .scale(60)
                  .rotate( rotation )
                  //.center( center )
                  .translate([0, 0])
                  .clipAngle(90);

              // initialize path generator - this is a function!
              var path = d3.geoPath()
                  .projection(projection);
                  //.pointRadius(2);

              var globeTarget = d3.select("svg")
                  .append("g")
                  .attr("class", "globe-container")
                  .attr("transform", "translate(100, 100)")
                  .on("mouseover", (d, i, n) => {
                    //console.log('globe mouseover')
                    //growGlobe();                                                            
                  });

              //Create the base globe
              var backgroundCircle = globeTarget.append("circle")
                  .attr('cx', 0)
                  .attr('cy', 0)
                  .attr('r', projection.scale())
                  .attr('class', 'globe')
                  .attr("fill", "black")
                  .attr("fill-opacity", "0.5");

              //Add all of the countries to the globe
              var continentPaths = globeTarget.selectAll("path")
                  .data(data.continents)
                  .enter()
                  .append("path")
                  .attr("class", "feature")
                  .attr("fill", "white")
                  .attr("fill-opacity", "0.5")
                  .attr("d", path);  // this is where svg data gets added, based on data transformed through path generator
                  
              //Add marker at the center of the globe 
              var Circle = globeTarget.append("text")
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('text-anchor', 'middle')
                  .attr('dominant-baseline', 'middle')
                  .attr('font-size', '2em')
                  .attr("fill", "white")
                  .attr("fill-opacity", "1")
                  .text("+")

              var countryList = [];
              item.countries.map( (country) => {
                countryList.push( country.properties.ADMIN );
              });

              //Add list of countries under globe
              var countryList = globeTarget.append("text")
                .attr('x', 0)
                .attr('y', 60)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr("fill", "white")
                .selectAll('tspan')
                .data(countryList)
                .enter()
                .append('tspan')
                .attr('x', 0)
                .attr('dy', 15)
                .text(function(d) { return d });

              }
              

              
           
        }// draws/redraws globe widget for highlighted language
        
        function connectTwoElements( id, from, to, color ) { // draws line between two elements, expects two 2d coordinate pair arrays

            var target = d3.select(`#ID${id}`);
              
            target.append("path")
              .attr("d", d3.linkHorizontal()
                .source(function () { return [from[0] - to[0], from[1] - to[1]]  })
                .target(function () { return [0, 0] }))
                .attr("stroke", color)
                .attr("stroke-width", '1')
                .attr("fill", "none");

            target.append("text")
              .attr("dy", "1.5em")
              .attr("text-anchor", "middle")
              .style("fill", "white")
              .text(function(d) { return d.properties.NTAName });
              
            target.append("circle")
                .attr("fill", "white")
                .attr("r", 3);
            }
            
        /***************************** DATA LOADING **************************/  
              
        function updateSelectionData(id, callback) {
          getDataSingle( 'languages', id, (result) => {
              var resultObj = result;
              
              
              if (resultObj.countries) {
                getData( 'countries', resultObj.countries, (resultCountries) => {
                  resultObj.countries = resultCountries;
                  data.selected = resultObj;
                  
                  
                })
              }
              if (resultObj.neighborhoods) {
                getData( 'neighborhoods', resultObj.neighborhoods, (resultNeighborhoods) => {
                  resultObj.neighborhoods = resultNeighborhoods;
                  data.selected = resultObj;
                })
              }
              //console.log(resultObj);
              data.selected = resultObj;
              if (callback) callback()
          });
        }
        
        function updateData(mode, input, callback) {
          //console.log('update data called')
          setTimeout(function() {
            if (mode == 'langname' ) {
              getData( 'languages', [], (response) => {  // get main language data
                filterData( input, response, (filterresponse) => {
                  data.languages = filterresponse;
                  getData( 'countries', [], (response) => {
                    data.countries = response;
                    getData( 'neighborhoods', [], (response) => {
                      data.neighborhoods = response;
                      getData( 'continents', [], (response) => {
                        data.continents = response;
                        if (callback) {callback()};
                      })
                    })
                  })
                })
              })
            }
          }, 250);
        }
        
        function filterData(string, data, callback) {
          let results = fuzzy.filter(string, data, searchOptions);
          let matches = results.map(function(el) { return el.original; });          
          callback(matches)
        }
             
        function getData( collection, ids, callback ) { // id is optional
          
          let url = `../${collection}`;
          d3.json(url, function(json){
            if (ids.length > 0) {
              //console.log(ids);
              let filteredJson = []
              
              async.each(
                json,
                
                (item, callback) => {
                  //console.log(ids)
                  //console.log(item._id)
                  //console.log( ids.indexOf(item._id)
                  if ( ids.indexOf(item._id) > -1 ) {
                    filteredJson.push(item);
                  }
                  callback();
        
                }, 
                
                (err, transformed) => {
                  //console.log(filteredJson)
                  callback(filteredJson);
                }
                
              );

            } else {
              //console.log(json);
              callback(json);        
            }
          })
        }
        
        function getDataSingle( collection, id, callback ) {
          let url = `../${collection}/${id}`;
          d3.json(url, function(json){
              //console.log('getdatasingle request')
              //console.log(url)
              //console.log(json)
              callback(json)
          });
        }
        
        /*********************** UTILITY *************************************/
         
        function logResult(input) {
          //console.log(input);
        }
        
        function parseTransform (input) { // convert svg transform string into object
            var a= input.replace(/\s/g,'')
            var b={};
            for (var i in a = a.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?)+\))+/g))
            {
                var c = a[i].match(/[\w\.\-]+/g);
                b[c.shift()] = c;
            }
            return b;
        }
